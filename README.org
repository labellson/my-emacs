#+TITLE: My Emacs Config
#+AUTHOR: Daniel Laguna
#+EMAIL: labellson@gmail.com

* Introduction
The idea of generating an emacs config file using =org-mode= is taken from
[[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs starts, all the elisp code
blocks from this file are parsed and used to generate the config. This is done
through [[http://orgmode.org/worg/org-contrib/babel/][org-babel]]. =Babel= is Org-mode's ability to execute source code within
=org-mode= documents.

To use this config file, you need to evaluate this file on startup. This can be
done writing this line ~(org-babel-load-file "~/.my-emacs/README.org")~ into
your [[file:init.el][init.el]].

*NOTE*: This file assumes that your =org-mode= config file is located into
=~/.my-emacs/README.org=.

* Basic Emacs Setup
** My information
Relevant personal information that Emacs needs.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Laguna"
    user-mail-address "labellson@gmail.com"
    calendar-latitude 40.33
    calendar-longitude -3.76
    calendar-location-name "Madrid, Spain")
#+END_SRC

** Adding MELPA
MELPA is the main package repository for Emacs. There are more repositories and
you are able to add more than one. *But make sure you are using HTTPS!!*.

#+BEGIN_SRC emacs-lisp
;; Set up the package manager and repositories
(require 'package)

(add-to-list 'package-archives '("MELPA" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))

(setq package-enable-at-startup nil)
(package-initialize)
#+END_SRC

** Install ~use-package~
Emacs has a built-in package manager that makes easy to install
packages. =use-package= makes things easier though. As a consequence, I need to
write less ~emacs-lisp~ code, and along with =org-mode=, it makes easier the
maintenance of a configuration file.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

** TAB
=<TAB>= key run indentation in most of the major mode. Sometimes, I want to
=<TAB>= behaves as inserting a tab character. I can do this typing =C-q-<TAB>=
but I don't like the default widht. So...

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

** Disable =yes-or-no= messages
There are different types of confirmation prompts in Emacs. One of them forces
you to write =yes= and the other one only to press =y=, so I disable the first
type.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disabling the default startup message
I prefer to have a scratch buffer ready when booting up with =org-mode= running

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
	  initial-scratch-message nil
	  initial-major-mode 'org-mode)
#+END_SRC

** Disable the warning when killing a buffer with process
When a buffer has an associated process, Emacs will prompt you when trying to
kill it asking for confirmation. I preferred to disable this behaviour.

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
	  (remq 'process-kill-buffer-query-function
			 kill-buffer-query-functions))
#+END_SRC

** Fix scroll
Setting this values will force one-line scrolling everywhere (mouse and
keyboard), resulting most of the times in a smoother scrolling than the actual
smooth scolling.

#+BEGIN_SRC emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000
	  mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't)
#+END_SRC

** Wrap lines
Setting this value, the lines will wrap in all buffers when collapsing.
   
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC
** Set the backups folder
Backups are always fancy. But emacs, blows up all my project folders with
swarms of =#foo#= files. That's why I set them to a backup folder and stop them
from polluting everywhere.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
	  backup-by-copying t
	  version-control t
	  delete-old-versions t
	  kept-new-versions 20
	  kept-old-versions 5)
#+END_SRC

** Auto-fill comments
For our comments (only comments, not code) to be automatically filled in
programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** Increase or decrease font size across all buffers
Extracted from a file in [[https://github.com/purcell/emacs.d][Steve Purcell’s Emacs configuration]], it is possible to
use this functions to increase or decrease the text scale in all
Emacs. Specially useful for presentations, demos and other shows alike.

#+BEGIN_SRC emacs-lisp
(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

** Add functions to determine system 
One liner functions to know in which system we are running.

#+BEGIN_SRC emacs-lisp
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))

(defun system-is-chip ()
  (interactive)
  (string-equal system-name "chip"))

(defun system-is-windows ()
  (interactive)
  (or (string-equal system-name "windows-nt")
	  (string-equal system-name "cygwin")))
#+END_SRC

** Tramp configuration
The Transparent Remote Access, Multiple Protocols enables editing remote files
using different protocols. It's very easy to use because the user doen not have
to worry about anything.

I only had one problem with it. TRAMP doesn't recognized the remote shell
prompt because the server used a customised prompt, so TRAMP hangs with the
message "/Waiting for prompts from remote shell/". This is easy to fix adding
~.*~ to the ~tramp-shell-prompt-pattern~ variable [[https://www.emacswiki.org/emacs/TrampMode#toc12][as said in emacs wiki]].

#+BEGIN_SRC emacs-lisp
(setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*")
#+END_SRC

** Esc key as C-g
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC
** Define keybindings to =eval-buffer= on init and open =README.org=
Really loving this emacs =org-mode= configuration. It was easier to reload the
configuration on the fly: ~M-x eval-buffer RET~. However the buffer to evalute
is not this one, but =.emacs.d/init.el=. That's whu it's probably a better idea
to define a new keybinding that automatically reloads that buffer.

#+BEGIN_SRC emacs-lisp
(defun reload-emacs-configuration ()
  "Reload the configuration"
  (interactive)
  (load "~/.emacs.d/init.el"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
  (find-file "~/.my-emacs/README.org"))

(global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
(global-set-key (kbd "C-c c o") 'open-emacs-configuration)
#+END_SRC

** Scroll in the compilation buffer
It's really annoying to not have the last part of the output in the screen when
compiling. This automatically scrolls the buffer for you as the output is printed.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

** Add other keybindings
In this section goes all these keybindings that don't really fit anywhere else.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c b") 'bookmark-jump)
#+END_SRC
* Emacs GUI
** Disabling GUI bars
The Emacs GUI client has this tools bars that I don't like too much. I prefer a
clean layout with the simple mode-line and without a scroll-bar, as if it were
Vim.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Highlight changed and uncommited lines
Use the =git-gutter-fringe= package for that. I have it activated for
=prog-mode= and =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :ensure t
  :config

  (add-hook 'prog-mode-hook 'git-gutter-mode)
  (add-hook 'org-mode-hook  'git-gutter-mode))
#+END_SRC

** Setting solarized theme
I've been using =grubvox= dark theme for a long time on =vim= and in my firsts
steps with =emacs=. But, I've always been in love with =solarized-light=. On my
opinion, =solarized= doesn't looks pretty on =vim=. But looks sexy on =emacs=.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :ensure t
  :init
  (setq solarized-use-variable-pitch nil)
  :config
  (load-theme 'solarized-light t)
  (set-face-attribute 'org-block nil :background "#f9f2d9"))
#+END_SRC

** Mode-line configuration
These two packages developed by [[https://github.com/tarsius][Jonas Bernoulli]], provide a beautiful and simple
mode-line that shows all the information in a beautiful and minimalistic way.
The general mode-lin aesthetics and distribution is provided by =moody=, while
=minions= hide all the minor modes and provides an on-click menu to show
them. So, I don't need anymore the delight package to hide all the actually
active minor modes.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :ensure t
  :config

  (setq minions-mode-line-lighter "[+]")
  (minions-mode))

(use-package moody
  :ensure t
  :config

  (setq x-underline-at-descent-line t
		column-number-mode t)

  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)

  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))
#+END_SRC

** Highlight matching parenthesis
As the title says, this mode highlight matching parenthesis under the cursor
 
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode 1)
#+END_SRC

* Programming Modes
** =company=
[[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

Add =company-tng-frontend= if you like YCM Vim completion :P

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
    (setq company-tooltip-align-annotations t)
    (eval-after-load 'company
      '(progn
        (add-hook 'prog-mode-hook 'company-mode)
        (add-to-list 'company-frontends 'company-tng-frontend)
        (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
        (define-key company-active-map [tab] 'company-complete-common-or-cycle)
        (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
        (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
        
        (define-key company-mode-map (kbd "C-<SPC>") 'company-complete))))
#+END_SRC

With =company-flx= we add fuzzy matching to =company=. But it seems only work
with =company-capf= backend.

#+BEGIN_SRC emacs-lisp
(use-package company-flx
  :ensure t
  :config
    (eval-after-load 'company
      (company-flx-mode +1)))
#+END_SRC
   
** C/C++
I've been using *NeoVim* with =YouCompleteMe= for C/C++ development. But, I
want to change my default text editor to emacs. So, this section sums up my
research on C/C++ related emacs packages. 

*** =cmake-mode=
This package provides syntax highlight in =CMakeLists.txt= files and
completions via =company-cmake= backend. Very useful when creating the =CMake=
files.

#+BEGIN_SRC emacs-lisp
(use-package cmake-mode
  :ensure t)
#+END_SRC

*** =emacs-ycmd=
 I've been testing =rtags= and =irony= modes, but I could not properly
 configurate. But, I've seen there's a client for =ycmd= on emacs too.

 =emacs-ycmd= is an emacs mode that takes care of managing a ycmd server and
 fetching completions from that server to offer some IDE-like functionality for
 C/C++.

 In order to use this package the [[https://github.com/Valloric/ycmd][ycmd]] server must be compiled. For C/C++
 completion: ~./build.py --clang-completer~.

 =ycmd= search the headers using the ~.ycm_extra_conf.py~ and
 ~compile_commands.json~ compilation database. This last file is easilly
 generated if using =cmake= as the build tool and passing
 ~-DCMAKE_EXPORT_COMPILE_COMMANDS=ON~ flag. But for projects that doesn't use
 =cmake= you can use [[https://github.com/rizsotto/Bear][BEAR]], that intercept the ~exec~ calls issued by the build
 tool and generates the database. You can invoke it like this: ~bear
 <your-build-command>~.

 #+BEGIN_SRC emacs-lisp
(use-package ycmd
  :ensure t
  :config

  (set-variable 'ycmd-server-command `("python3",
									   (file-truename "~/.ycmd/ycmd")))
  (set-variable 'ycmd-global-config (expand-file-name "~/.ycmd/.ycm_extra_conf.py"))

  (add-hook 'c++-mode-hook #'ycmd-mode)
  (add-hook 'ycmd-mode-hook 'ycmd-eldoc-setup))
 #+END_SRC

 To enable code completion with company install the backend.

 #+BEGIN_SRC emacs-lisp
(use-package company-ycmd
  :ensure t
  :config

  (company-ycmd-setup)

  (eval-after-load 'company
	'(add-to-list 'company-backends 'company-ycmd)))
 #+END_SRC

 For live code checking =flycheck-ycmd= must be installed.

 #+BEGIN_SRC emacs-lisp
(use-package flycheck-ycmd
  :ensure t
  :config

  (flycheck-ycmd-setup)

  (add-hook 'ycmd-mode-hook 'flycheck-ycmd-setup))
 #+END_SRC

** Python
In order to use ipython as default interpreter set these lines below.

#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
       python-shell-interpreter-args "--simple-prompt -i")
#+END_SRC

I've set a global =tab-width= in basic emacs setup. But it seems not working in
=python-mode=.

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
      (lambda ()
        (setq tab-width 4)))
#+END_SRC

*** =anaconda-mode=
[[https://github.com/proofit404/anaconda-mode][Anaconda]] provides context code completion, jump to definitions, find references
and documentation view through =eldoc= for python mode. Its usage is very
simple and it integrates with =company-mode=.

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :ensure t
  :config
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC

**** Default Keybinding
| Keybinding | Description                    |
|------------+--------------------------------|
| C-M-i      | anaconda-mode-complete         |
| M-.        | anaconda-mode-find-definitions |
| M-,        | anaconda-mode-find-assignments |
| M-r        | anaconda-mode-find-references  |
| M-*        | anaconda-mode-go-back          |
| M-?        | anaconda-mode-show-doc         |
   
*** =company-anaconda=
This is a backend for =company-mode= that works with =anaconda-mode=. Necessary
if you want autocompletion.

#+BEGIN_SRC emacs-lisp
(use-package company-anaconda
  :ensure t
  :config

    (eval-after-load "company"
      '(add-to-list 'company-backends '(company-anaconda :with company-capf))))
#+END_SRC

*** Package for Python docstrings
This package adds some nice features like automatic creation of docstrings and
highlighting in them. There is also another package for better highlight and
indentation of the comments.

#+BEGIN_SRC emacs-lisp
(use-package sphinx-doc
  :ensure t
  :hook (python-mode . sphinx-doc-mode))

(use-package python-docstring
  :ensure t
  :config (setq python-docstring-sentence-end-double-space nil)
  :hook (python-mode . python-docstring-mode))
#+END_SRC

*** Jupyter Notebook
=EIN= provides a client for =IPython= and =Jupyter= notebooks inside
emacs. This allows use all the emacs features inside the notebooks.

#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t
  :hook (ein:notebook-multilang-mode
		 . (lambda () (ws-butler-mode -1) (visual-line-mode)))
  :custom-face
  (ein:cell-input-area ((t (:background "#f9f2d9")))))
#+END_SRC
** Javascript
*** =js-2mode=
Better [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html][Javascript mode]].

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :config

  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (add-hook 'js2-mode-hook #'js2-imenu-extras-mode))
#+END_SRC
** Docker files
Spotify created a mayor mode that provides syntax highlighting as well as the
ability to build the image directly from the buffer with ~C-c C-b~.

Also you can specify the image name in the file itself as in =org-mode=
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html][File-Local Variables]].

#+BEGIN_EXAMPLE
## -*- docker-image-name: "your-image-name-here" -*-
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :config

  (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))
#+END_SRC

Also =docker-compose-mode= provides syntax highlighting and completions for
=docker-compose= files using company as backend.

#+BEGIN_SRC emacs-lisp
(use-package docker-compose-mode
  :ensure t
  :hook (docker-compose-mode . company-mode))
#+END_SRC

** =hideshow=
This minor mode provides selectively folding for code and comment
blocks. Blocks are defined per mayor mode. It cames pre-configured with default
mayor modes like =c-mode, c++mode..=

You can configure this minor mode and enable it in different mayor modes with
this config. This [[https://emacs.stackexchange.com/questions/2884/the-old-how-to-fold-xml-question][issue]] explains how to configure for =nxml-mode=.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :ensure t
  :bind ("C-c h" . hs-toggle-hiding)
  :config
  (add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
			   nxml-forward-element
               nil))
)

(add-hook 'nxml-mode-hook 'hs-minor-mode)
(add-hook 'python-mode-hook 'hs-minor-mode)
#+END_SRC
* WIP
These source blocks needs to be moved to its corresponding sections.

#+BEGIN_SRC emacs-lisp
(use-package org-autolist
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))

(use-package org-bullets
  :ensure t)
  ;:config
  ;(progn
  ;  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  ;  (setq org-bullets-bullet-list
  ;        '("\u25c9" "\u25ce" "\u25cb" "\u25cb" "\u25cb" "\u25cb"))))

#+END_SRC

* Org-mode
** Enable =auto-fill-mode=
   This conf enables 80 characters auto filling per line inside =org-mode=. I
believe that 80 character per line enhances the readability of a text file.

If you want a visual behaviour inside =emacs= instead into the raw text file
check [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]].

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
(setq-default fill-column 79)
#+END_SRC

** Set the directory
Set the path of the org directory

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Drive/org/")
#+END_SRC

** Setting up the agenda
I'm triying to use the =org= agenda in order to organize all my workflow
tasks. So in this section there are some agenda useful configurations.

First, I'm defining where are my agenda files. I like to have it synced with
Google Drive, in order to have always ready a back up. Also =org= can handle
multiple agenda files, so you can add more files or folder to the list.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list "~/Drive/org/agenda.org"))
#+END_SRC

As I said, I'm planning keep track of my tasks on the agenda. Thus I need to
add some workflow states to the default *TODO* | *DONE* defined on Emacs

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
	  '((sequence "TODO" "IN-PROGRESS" "WAITING" "|" "DONE" "CANCELED")))
#+END_SRC

Also setting this keybinding allows me take quick looks to the agenda by week.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c t a") 'org-agenda-list)
#+END_SRC   

In order to add items to the agenda from anywhere in Emacs, we need to use
=org-capture=. When you call it, a split will prompt asking you to select a
template to use in order to add the task. By default, there are not templates,
so lets define one along with a keybinging to call it.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
	  '(("a" "My TODO task format." entry
		 (file "agenda.org")
		 "* TODO %?
SCHEDULED: %t")))

(defun my-org-task-capture ()
  "Capture a task with my default template."
  (interactive)
  (org-capture nil "a"))

(global-set-key (kbd "C-c c c") 'my-org-task-capture)
#+END_SRC

Also, I want an easy way to add tasks from the agenda view. So lets bound the =c= key
to the default capture command. In addition, pressing =C-u c= will open the
default =org-capture= dialog prompting the different capture types.

The key binding is set in [[ref:sec:agenda-key-bindings][Agenda key bindings]] section.

#+BEGIN_SRC emacs-lisp
(defun my-org-agenda-capture (&optional vanilla)
  "Capture a task in agenda mode, using the date at point.

If VANILLA is non-nil, run the standard `org-capture'."
  (interactive "P")
  (if vanilla
      (org-capture)
    (let ((org-overriding-default-time (org-get-cursor-date)))
      (org-capture nil "a"))))
#+END_SRC

Finally, I want to see my daily agenda as I defined in my custom view in the
section [[ref:sec:agenda-custom-commands][Agenda custom commands]]. So, as I take quick looks to the daily agenda
the =S-SPC= binding fits perfect.

#+BEGIN_SRC emacs-lisp
(defun my-pop-to-org-agenda (&optional split)
  "Visit the org agenda, in the current window or a SPLIT."
  (interactive "P")
  (org-agenda nil "d")
  (when (not split)
    (delete-other-windows)))

(global-set-key (kbd "S-SPC") 'my-pop-to-org-agenda)
#+END_SRC

Below these lines, there are some tweaks that I've found for the agenda.

Performing a text search ("s" selection from =org-agenda=) include all the text
from the file list in =org= agenda.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+END_SRC

This option force you to mark all child tasks as *DONE* before you can mark the
parent as *DONE*.

#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

This one insert a timestamp on the task when it was marked as done. Very useful
in order to maintain a log of when the tasks are done. Also the same idea, but
for logging how many the times a deadline or an scheduled date was changed.

#+BEGIN_SRC emacs-lisp
(setq org-log-done (quote time))
(setq org-log-redeadline (quote time))
(setq org-log-reschedule (quote time))
#+END_SRC

*** Agenda key bindings
:PROPERTIES:
:CUSTOM_ID: sec:agenda-key-bindings
:END:

In this section are all the key bindings related to the agenda mode. They need
to be evaluated after the =org-agenda-mode= was loaded, otherwise =Emacs= would
fail to evaluate them.

- Rebind the =k= and =j= keys to move up and down as in =evil-mode=.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-agenda
  '(progn
	 (define-key org-agenda-mode-map "j" 'org-agenda-next-item)
	 (define-key org-agenda-mode-map "k" 'org-agenda-previous-item)
	 (define-key org-agenda-mode-map "c" 'my-org-agenda-capture)))
#+END_SRC

** Agenda custom commands
:PROPERTIES:
:CUSTOM_ID: sec:agenda-custom-commands
:END:
This custom commands are intended to define my custom view of the agenda. All
the ideas are inspired on [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][this Aaron Bieber]] blog entry.

The defined agenda view shows the tasks for today, along with the high priority
and all that aren't scheduled for any date.

#+BEGIN_SRC emacs-lisp
(defun my-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun my-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(setq org-agenda-custom-commands
      '(("d" "Daily agenda and all TODOs"
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))
          (agenda "" ((org-agenda-span 1)))
          (alltodo ""
                   ((org-agenda-skip-function '(or (my-org-skip-subtree-if-habit)
                                                   (my-org-skip-subtree-if-priority ?A)
                                                   (org-agenda-skip-if nil '(scheduled deadline))))
                    (org-agenda-overriding-header "ALL normal priority tasks:")))))))
#+END_SRC

** =evil= integration with =org-mode=
I'm very used to =Vim=, that's why I use =evil-mode=. But, it doesn't have a
default integration with =org-mode=. That's where =evil-org= package helps defining some useful
keybindings for a =Vim= key-map fan.

#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t
  :hook (org-mode . evil-org-mode))
#+END_SRC
** Native =TAB= in source blocks
By default =TAB= keystroke doesn't indent in =org= source blocks. Typing
=C-q-<TAB>= I can force a native =TAB= but I prefer this option that makes
=TAB= work as if the keystroke was issued in the code’s major mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

** =org-ref=
This is an =org-mode= module to handle citations, cross-references and
bibliographies.

We require the packages and set the default for the bibliography notes, the
main .bib bibliography and the directory where the PDFs can be downloaded to.

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t
  :config

  (setq org-src-preserve-indentation t)

  (setq org-latex-default-packages-alist
	(-remove-item
	 '("" "hyperref" nil)
	 org-latex-default-packages-alist))

  (add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
  (add-to-list 'org-latex-default-packages-alist
	       '("linktocpage,pdfstartview=FitH,colorlinks,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=blue,menucolor=black,urlcolor=blue"
		 "hyperref" nil)
	       t)

  (progn
    (setq org-ref-bibliography-notes "~/Drive/org/bibliography/notes.org"
          org-ref-default-bibliography '("~/Drive/org/bibliography/main.bib")
          org-ref-pdf-directory "~/Drive/org/bibliography/pdfs"
          org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))

  (setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5))
#+END_SRC

This enable the use of native =org-mode= labels in =org-ref= links, instead the
~label:org-ref~ style.

#+BEGIN_SRC emacs-lisp
(setq org-latex-prefer-user-labels t)
#+END_SRC
** IEEE export
For class assignments and who-knows-what in the future, I was able to integrate
a IEEE Conference template in org-mode export via Latex. To use it, just
include the IEEEtran class in your org file. It has not been thoroughly tested,
but its headers, index, abstract and general aesthetic works perfectly out of
the box.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
             t)
#+END_SRC

** Beamer export
We need to manually enable the export to Beamer option

#+BEGIN_SRC emacs-lisp
(use-package ox-beamer)
#+END_SRC

** Custom ellipsis
Custom ellipsis to use in the =org-mode= heading outline.
   
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " \u2935")
#+END_SRC
** Prettify symbols
This setting will prettify latex symbols like (~x_{subscript}~) and
superscripts (~x^{superscript}~). As a consequence, they will appear in =org=
as visual symbols.
   
#+BEGIN_SRC emacs-lisp
(setq-default org-pretty-entities t)
#+END_SRC
** Use syntax highlight in source blocks
When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

** Source syntax highlight in =latex= exports
Using =org-mode= =latex= export you can get syntax highlighting in pdf using
the =minted= package, wich uses =Python= =pygments= package. This snippet was
taken from [[http://joonro.github.io/blog/posts/org-mode-outputdir-minted-latex-export.html][Joon's Blog]]. [[https://github.com/gpoore/minted/issues/92][Issue]] ~cache=false~.

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("cache=false" "minted"))
(setq org-latex-listings 'minted)
#+END_SRC

** Auto cleanup =latex= intermediary files
I hate all this intermediary files that =latex= creates. Just blow up all my
directories. So, I've found a solution in this [[https://emacs.stackexchange.com/questions/23982/cleanup-org-mode-export-intermediary-file][emacs stack exchange question]].

#+BEGIN_SRC emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl")))
#+END_SRC

** Time tracking: Clocking
I've recently discovered this feature and is awesome. It enables time tracking
for tasks inside an agenda file.

~C-c C-x C-i~ Starts the clock on the current time
~C-c C-x C-o~ Stops the current active clock

With this option all the =CLOCKS= will be grouped into a =:CLOCKING:= entry

#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
#+END_SRC

* Packages & Tools
** Evil mode
I'm very used to =Vim= and prefer its keybindings over the Emacs
ones. =Evil-mode= provides keybindings and emulates the main features of =Vim=.

This configuration enables leader key function and highlihgt persistence on
searches.
   
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :config

  (evil-mode 1)

  ;; Evil key bindings
  (define-key evil-motion-state-map "j" 'evil-next-visual-line)
  (define-key evil-motion-state-map "k" 'evil-previous-visual-line)

  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)

    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "x" 'counsel-M-x
      "<SPC>" 'evil-search-highlight-persist-remove-all
	  "i" 'counsel-imenu))

  (use-package evil-search-highlight-persist
   :ensure t
   :config
   (global-evil-search-highlight-persist t))

	;; Add these evil keybindings in Emacs mode
	(evil-add-hjkl-bindings occur-mode-map 'emacs
	(kbd "/")       'evil-search-forward
	(kbd "n")       'evil-search-next
	(kbd "N")       'evil-search-previous
	(kbd "C-d")     'evil-scroll-down
	(kbd "C-u")     'evil-scroll-up
	(kbd "C-w C-w") 'other-window))
#+END_SRC

** =which-key=
A useful package that displays the possible key combinations when you start a
new key command.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode))
#+END_SRC
** Add icons with =all-the-icons=
This package comes with a set of icons for Emacs. You have to install them with
~all-the-icons-install-fonts~

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

** =dired=
This is the default Emacs system directory. It's super useful, specially when
I'm in some OS where I don't feel very confortable :P Dired allows you
navigation through the filesystem using a text buffer. That's very useful
because if you press =C-x C-q= in the dired buffer it turns into a writeable
buffer so you can edit files or directories as a regular textfile. Setting to
true ~dired-dwin-target~ enables the dired Do What I Mean behaviour. With that,
if you try to rename a file with a second buffer open, it will asume that you
want to move it there. Same with copy and other operations.

In this [[https://www.youtube.com/watch?v=7jZdul2fC94][video]] you can see a reference of what you can do with =dired= mode.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook (dired-mode . dired-hide-details-mode)
  :config
  (setq dired-dwim-target t))

(use-package all-the-icons-dired
  :ensure t
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package dired-sidebar
  :ensure t
  :bind (("C-c s" . dired-sidebar-toggle-sidebar)))
#+END_SRC

** Move buffers around
There's no fast way to swap buffers location in Emacs by default. To do it, a
good option is to use =buffer-move= package and use these key bindings.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-x w <up>"    . buf-move-up)
		 ("C-x w <down>"  . buf-move-down)
		 ("C-x w <left>"  . buf-move-left)
		 ("C-x w <right>" . buf-move-right)
		 ("C-x w k"       . buf-move-up)
		 ("C-x w j"       . buf-move-down)
		 ("C-x w h"       . buf-move-left)
		 ("C-x w l"       . buf-move-right)))
#+END_SRC

** Relative margin line numbers
This setting enables the margin line numbers with the relative number mode.
 
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
  :ensure t
  :hook (prog-mode . nlinum-relative-mode)
  :config

  (nlinum-relative-setup-evil)
  (setq nlinum-relative-redisplay-delay 0))
#+END_SRC
** Zsh like completion
=zlc= provides Zsh like completion for the default minibuffer.

#+BEGIN_SRC emacs-lisp
;; Zsh Tab completion for minibuffer
(use-package zlc
  :ensure t
  :config
  (zlc-mode t))
#+END_SRC
** Environment variables
Emacs doesn't look to my user environment variables. Therefore, I can't get
python completion working with my own modules because it doesn't look for my
~$PYTHONPATH~. =exec-path-from-shell= is an Emacs library to ensure variables
inside Emacs look the same as in the user's shell. By default it sets the user
~$MANPATH~ and ~$PATH~. Also you can copy other environment variables by
customizing ~exec-path-from-shell-variables~ or by calling
~exec-path-from-shell-copy-env~.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :config

  (when (memq window-system '(mac ns x))
	(add-to-list 'exec-path-from-shell-variables '"PYTHONPATH")
	(exec-path-from-shell-initialize)))
#+END_SRC

** Spell checking
Emacs comes with =ispell= a very useful spell checker if you use emacs to write
notes or documents as I do. =ispell= needs a completion tool to review the
text. I've installed  =hunspell= in my Arch Linux laptop.

I set spanish as default language for spell checking because is my native
language. But, I can use =M-x ispell-change-dictionary= if I want to change the
spell checking language.

The last two lines prevents =ispell= to check inside =org= source blocks and
sections.
   
#+BEGIN_SRC emacs-lisp
;; Spell checker
(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-dictionary "es_ES")
  (setq ispell-really-hunspell t))

(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
#+END_SRC
** =ivy=
=ivy= is a minimalistic completion engine. It supports fuzzy matching. But I
don't like this behaviour on =swiper= search engine. So, I deactivated setting
the default regexp builder with ~(swiper . ivy--regex-plus)~.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :demand t
  :config

  (ivy-mode) 
  (setq ivy-use-virtual-buffers t
		ivy-count-format "%d/%d ")

  (setq ivy-wrap t)

  ; Fuzzy mode
  (setq ivy-re-builders-alist
		'((swiper . ivy--regex-plus) ; No Fuzzy matchin for swiper
		  (t      . ivy--regex-fuzzy)))

  (setq ivy-initial-inputs-alist nil)

  :bind (("C-s" . swiper)
		 :map ivy-minibuffer-map
		 ("RET" . ivy-alt-done)
		 ("C-j" . ivy-next-line)
		 ("C-k" . ivy-previous-line))) 
#+END_SRC

Also, this alternative package complement =ivy=

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :ensure t
  :demand t
  :config (ivy-rich-mode))
#+END_SRC

=counsel= is collection of Ivy-enhanced versions of common Emacs commands. So,
enhances the emacs user experience ;)

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :demand t) 
#+END_SRC

=swiper= is an Ivy-enhanced alternative to isearch

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :demand t)
#+END_SRC

** =projectile=
Enables different tools and functions to deal with files related to a
project. It works out of the box, since it will detect your *VCS* files
automatically and set it as the root of the project. If it doesn't, you can
just create an empty =.projectile= file in the root of your project.

I have it configured to ignore all files that has not been staged in the
project.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config

  (projectile-global-mode t)
  (setq projectile-use-git-grep t)

  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+END_SRC

Also, the =counsel-projectile= extension adds integration with =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :config (counsel-projectile-mode t))
#+END_SRC
** =flycheck=
=Flycheck= brings on-the-fly syntax checking for different languages. It comes
already with support for a lot of languages and can also use other packages as
backend.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'flycheck-mode)
  (set-face-underline 'flycheck-error '(:color "Red1" :style line)))
#+END_SRC

** =smartparens=
Auto-close parenthesis and other characters. Very useful in =prog-mode=.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config

  (add-hook 'prog-mode-hook #'smartparens-mode)
  (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
#+END_SRC
** Smooth scrolling
This package keeps the cursor away from the top and bottom of the current
buffer's window in order to keep lines of context around the point visible as
much as possible.

#+BEGIN_SRC emacs-lisp
; Smooth scrolling on file limits
(use-package smooth-scrolling
  :ensure t
  :config
  (smooth-scrolling-mode 1))
#+END_SRC
** Clipboard integration
=simple-clip= enables clipboard system integration from emacs.
   
#+BEGIN_SRC emacs-lisp
; SimpleClip Super+C Super+X Super+V
(use-package simpleclip
  :ensure t
  :config
  (simpleclip-mode 1))
#+END_SRC

** PDF Tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config

  (pdf-tools-install))

#+END_SRC
  
There's a conflict between =evil-mode= and =pdf-view-mode=. =evil= cause that
pdf display keeps blinking. [[https://github.com/politza/pdf-tools/issues/201][xuhdev]] gives a solution to deal with this conflict.

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'pdf-view-mode 'emacs)
(add-hook 'pdf-view-mode-hook
  (lambda ()
    (set (make-local-variable 'evil-emacs-state-cursor) (list nil))))
#+END_SRC
* Acknowledgments
- Thanks to Diego Vicente. He discovered me Emacs and =org-mode=. Also, many
  aspects of my Emacs file are inspired by his [[https://github.com/DiegoVicen/my-emacs][config file]].
