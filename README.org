#+TITLE: My Emacs Config
#+AUTHOR: Daniel Laguna
#+EMAIL: labellson@gmail.com

* Introduction
The idea of generating an emacs config file using =org-mode= is taken from
[[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs starts, all the elisp code
blocks from this file are parsed and used to generate the config. This is done
through [[http://orgmode.org/worg/org-contrib/babel/][org-babel]]. =Babel= is Org-mode's ability to execute source code within
=org-mode= documents.

To use this config file, you need to evaluate this file on startup. This can be
done writing this line ~(org-babel-load-file "~/.my-emacs/README.org")~ into
your [[file:init.el][init.el]].

*NOTE*: This file assumes that your =org-mode= config file is located into
=~/.my-emacs/README.org=.

* Basic Emacs Setup
** My information
Relevant personal information that Emacs needs.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Laguna"
    user-mail-address "labellson@fastmail.com"
    calendar-latitude 40.33
    calendar-longitude -3.76
    calendar-location-name "Madrid, Spain")
#+END_SRC

** Adding MELPA
MELPA is the main package repository for Emacs. There are more repositories and
you are able to add more than one. *But make sure you are using HTTPS!!*.

#+BEGIN_SRC emacs-lisp
;; Set up the package manager and repositories
(require 'package)

(add-to-list 'package-archives '("MELPA" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))

(setq package-enable-at-startup nil)
(package-initialize)
#+END_SRC

** Install ~use-package~
Emacs has a built-in package manager that makes easy to install
packages. =use-package= makes things easier though. As a consequence, I need to
write less ~emacs-lisp~ code, and along with =org-mode=, it makes easier the
maintenance of a configuration file.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

** TAB
=<TAB>= key run indentation in most of the major mode. Sometimes, I want to
=<TAB>= behaves as inserting a tab character. I can do this typing =C-q-<TAB>=
but I don't like the default widht so I change it to 4. Also, I want to try
white spaces indentation so I deactivated the tab based indentation.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)

(global-set-key (kbd "C-c w") 'whitespace-mode)
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

(setq-default indent-tabs-mode nil)
#+END_SRC

** Set window title to buffer name
With this option the window title will be as the filename or like the name of
the unsaved buffer. Handy when you want to classify =*Emacs Anywhere*= unsaved
buffers and set as floating panes within i3. 
   
#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("%b"))
#+END_SRC

** Disable =yes-or-no= messages
There are different types of confirmation prompts in Emacs. One of them forces
you to write =yes= and the other one only to press =y=, so I disable the first
type.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disabling the default startup message
I prefer to have a scratch buffer ready when booting up with =org-mode= running

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
	  initial-scratch-message nil
	  initial-major-mode 'org-mode)
#+END_SRC

** Disable the warning when killing a buffer with process
When a buffer has an associated process, Emacs will prompt you when trying to
kill it asking for confirmation. I preferred to disable this behaviour.

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
	  (remq 'process-kill-buffer-query-function
			 kill-buffer-query-functions))
#+END_SRC

** Fix scroll
Setting this values will force one-line scrolling everywhere (mouse and
keyboard), resulting most of the times in a smoother scrolling than the actual
smooth scolling.

#+BEGIN_SRC emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000
	  mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't)
#+END_SRC

** Wrap lines
Setting this value, the lines will wrap in all buffers when collapsing.
   
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC
** Set the backups folder
Backups are always fancy. But emacs, blows up all my project folders with
swarms of =#foo#= files. That's why I set them to a backup folder and stop them
from polluting everywhere.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
	  backup-by-copying t
	  version-control t
	  delete-old-versions t
	  kept-new-versions 20
	  kept-old-versions 5)
#+END_SRC

** Auto-fill comments
For our comments (only comments, not code) to be automatically filled in
programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** Increase or decrease font size across all buffers
Extracted from a file in [[https://github.com/purcell/emacs.d][Steve Purcell’s Emacs configuration]], it is possible to
use this functions to increase or decrease the text scale in all
Emacs. Specially useful for presentations, demos and other shows alike.

#+BEGIN_SRC emacs-lisp
(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

** Add functions to determine system 
One liner functions to know in which system we are running.

#+BEGIN_SRC emacs-lisp
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))

(defun system-is-chip ()
  (interactive)
  (string-equal system-name "chip"))

(defun system-is-windows ()
  (interactive)
  (or (string-equal system-name "windows-nt")
	  (string-equal system-name "cygwin")))
#+END_SRC

** Tramp configuration
The Transparent Remote Access, Multiple Protocols enables editing remote files
using different protocols. It's very easy to use because the user doen not have
to worry about anything.

I only had one problem with it. TRAMP doesn't recognized the remote shell
prompt because the server used a customised prompt, so TRAMP hangs with the
message "/Waiting for prompts from remote shell/". This is easy to fix adding
~.*~ to the ~tramp-shell-prompt-pattern~ variable [[https://www.emacswiki.org/emacs/TrampMode#toc12][as said in emacs wiki]].

#+BEGIN_SRC emacs-lisp
(setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*")
#+END_SRC

** Esc key as C-g
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC
** Define keybindings to =eval-buffer= on init and open =README.org=
Really loving this emacs =org-mode= configuration. It was easier to reload the
configuration on the fly: ~M-x eval-buffer RET~. However the buffer to evalute
is not this one, but =.emacs.d/init.el=. That's whu it's probably a better idea
to define a new keybinding that automatically reloads that buffer.

#+BEGIN_SRC emacs-lisp
(defun reload-emacs-configuration ()
  "Reload the configuration"
  (interactive)
  (load "~/.emacs.d/init.el"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
  (find-file "~/.my-emacs/README.org"))

(global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
(global-set-key (kbd "C-c c o") 'open-emacs-configuration)
#+END_SRC

** Scroll in the compilation buffer
It's really annoying to not have the last part of the output in the screen when
compiling. This automatically scrolls the buffer for you as the output is printed.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

** Add other keybindings
In this section goes all these keybindings that don't really fit anywhere else.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c b") 'bookmark-jump)
#+END_SRC
* Emacs GUI
** Disabling GUI bars
The Emacs GUI client has this tools bars that I don't like too much. I prefer a
clean layout with the simple mode-line and without a scroll-bar, as if it were
Vim.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Highlight changed and uncommited lines
Use the =git-gutter-fringe= package for that. I have it activated for
=prog-mode= and =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :ensure t
  :config

  (add-hook 'prog-mode-hook 'git-gutter-mode)
  (add-hook 'org-mode-hook  'git-gutter-mode))
#+END_SRC

** Setting solarized theme
I've been using =grubvox= dark theme for a long time on =vim= and in my firsts
steps with =emacs=. But, I've always been in love with =solarized-light=. On my
opinion, =solarized= doesn't looks pretty on =vim=. But looks sexy on =emacs=.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :ensure t
  :init
  (setq solarized-use-variable-pitch nil)
  :config
  (load-theme 'solarized-light t)
  (set-face-attribute 'org-block nil :background "#f9f2d9"))
#+END_SRC

** Disable splitting frames to creating frames
This functionality is to be used along i3wm in order to delegate window management to i3 completely. There is also a couple of functions that must be overriden in order to make everything work seamlessly.

#+BEGIN_SRC emacs-lisp
;; Fix quit-window definitions to get rid of buffers
(defun quit-window-dwim (&optional args)
  "`delete-frame' if closing a single window, else `quit-window'."
  (interactive)
  (if (one-window-p)
      (delete-frame)
    (quit-window args)))

(defun running-i3 ()
  (string-match-p
   (regexp-quote "i3")
   (shell-command-to-string "echo $DESKTOP_SESSION")))

(defun set-up-i3 ()
  (interactive)
  (setq-default pop-up-frames 'graphic-only
                magit-bury-buffer-function 'quit-window-dwim
                magit-commit-show-diff nil)
  (substitute-key-definition 'quit-window 'quit-window-dwim
                             global-map)
  (substitute-key-definition 'quit-window 'quit-window-dwim
                             help-mode-map)
  (substitute-key-definition 'quit-window 'quit-window-dwim
                             Buffer-menu-mode-map)
  (message "Configuration for i3 applied"))

(when (running-i3)
  (set-up-i3))
#+END_SRC

This last line checks up if i3 is running and sets everything up (duh), but
when Emacs is started as a daemon in systemd or before actually running i3,
this check will fail. My solution is to run =emacsclient -e “(set-up-i3)”= in
my i3 configuration, so that i3 is the one actually telling the Emacs daemon to
get the proper settings.

** Mode-line configuration
These two packages developed by [[https://github.com/tarsius][Jonas Bernoulli]], provide a beautiful and simple
mode-line that shows all the information in a beautiful and minimalistic way.
The general mode-lin aesthetics and distribution is provided by =moody=, while
=minions= hide all the minor modes and provides an on-click menu to show
them. So, I don't need anymore the delight package to hide all the actually
active minor modes.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :ensure t
  :config

  (setq minions-mode-line-lighter "[+]")
  (minions-mode))

(use-package moody
  :ensure t
  :config

  (setq x-underline-at-descent-line t
		column-number-mode t)

  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)

  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))
#+END_SRC

** Highlight matching parenthesis
As the title says, this mode highlight matching parenthesis under the cursor
 
#+BEGIN_SRC emacs-lisp
(setq show-paren-delay 0)
(show-paren-mode 1)
#+END_SRC

* Programming Modes
** =company=
[[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

Add =company-tng-frontend= if you like YCM Vim completion :P

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
    (setq company-tooltip-align-annotations t)
    (eval-after-load 'company
      '(progn
        (add-hook 'prog-mode-hook 'company-mode)
        (add-to-list 'company-frontends 'company-tng-frontend)
        (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
        (define-key company-active-map [tab] 'company-complete-common-or-cycle)
        (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
        (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
        
        (define-key company-mode-map (kbd "C-<SPC>") 'company-complete))))
#+END_SRC

With =company-flx= we add fuzzy matching to =company=. But it seems only work
with =company-capf= backend.

#+BEGIN_SRC emacs-lisp
(use-package company-flx
  :ensure t
  :config
    (eval-after-load 'company
      (company-flx-mode +1)))
#+END_SRC
   
** C/C++
I've been using *NeoVim* with =YouCompleteMe= for C/C++ development. But, I
want to change my default text editor to emacs. So, this section sums up my
research on C/C++ related emacs packages. 

First of all lets set the indentation mode to the one you are used
to. Personally I prefer the one Stroustrup follows.

#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook (lambda () (c-set-style "stroustrup")))
#+END_SRC

*** =cmake-mode=
This package provides syntax highlight in =CMakeLists.txt= files and
completions via =company-cmake= backend. Very useful when creating the =CMake=
files.

#+BEGIN_SRC emacs-lisp
(use-package cmake-mode
  :ensure t)
#+END_SRC

*** =ggtags=
Provides an emacs frontend to GNU Global source code tagging system. You have
to generate the tags database calling ~gtags~ on top of the project.

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :hook (c++-mode . ggtags-mode)
  :bind (:map ggtags-mode-map
		 ("C-c g s" . ggtags-find-other-symbol)
		 ("C-c g h" . ggtags-view-tag-history)
		 ("C-c g r" . ggtags-find-reference)
		 ("C-c g f" . ggtags-find-file)
		 ("C-c g c" . ggtags-create-tags)
		 ("C-c g u" . ggtags-update-tags)
		 ("M-," . pop-tag-mark))
  :config

  (setq-local imenu-create-index-function #'ggtags-build-imenu-index))
#+END_SRC
	
*** Header completion with =company-c-headers=
This backend provides header completion from *system* headers 
~#include <header>~ and *user* provided per project ~#include "header"~.

In order to say where the backend have to look for the headers, you have to add
the system paths to the list ~company-c-headers-path-system~. And also per
project to the list ~company-c-headers-path-user~.
	
#+BEGIN_SRC emacs-lisp
(use-package company-c-headers
  :ensure t
  :config

  (add-to-list 'company-c-headers-path-system '"/usr/include/c++/8.2.1/")
  (add-to-list 'company-backends 'company-c-headers))
#+END_SRC

*** =semantic= minor mode
This package provides language-aware editing commands base on source code
parsers.

#+BEGIN_SRC emacs-lisp
(require 'semantic)

(global-semanticdb-minor-mode)
(global-semantic-idle-scheduler-mode)

;(add-hook 'c++-mode-hook (lambda () (semantic-mode)))
#+END_SRC
	
*** =irony=

#+BEGIN_SRC emacs-lisp
(use-package irony
  :ensure t
  :config

  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-irony
  :ensure t
  :config

  (eval-after-load 'company
    '(add-to-list 'company-backends 'company-irony)))
#+END_SRC

** Python
In order to use ipython as default interpreter set these lines below.

#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "--simple-prompt -i")
#+END_SRC

I've set a global =tab-width= in basic emacs setup. But it seems not working in
=python-mode=.

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
      (lambda ()
        (setq tab-width 4)))
#+END_SRC

** Regular Python configuration
=elpy= provides IDE-kind functionality for Emacs. Right now is the best python
package I tried for emacs. It comes with =flymake= as default syntax checker
though. I deactivated it in favor of =flycheck=.
   
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :config

  (elpy-enable)
  (remove-hook 'elpy-modules 'elpy-module-flymake)

  (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1))))
#+END_SRC

*** Package for Python docstrings
This package adds some nice features like automatic creation of docstrings and
highlighting in them. There is also another package for better highlight and
indentation of the comments.

#+BEGIN_SRC emacs-lisp
(use-package sphinx-doc
  :ensure t
  :hook (python-mode . sphinx-doc-mode))

(use-package python-docstring
  :ensure t
  :config (setq python-docstring-sentence-end-double-space nil)
  :hook (python-mode . python-docstring-mode))
#+END_SRC

*** Jupyter Notebook
=EIN= provides a client for =IPython= and =Jupyter= notebooks inside
emacs. This allows use all the emacs features inside the notebooks.

#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t
  :hook (ein:notebook-multilang-mode
		 . (lambda () (ws-butler-mode -1) (visual-line-mode)))
  :custom-face
  (ein:cell-input-area ((t (:background "#f9f2d9")))))
#+END_SRC
** Cython
I am very curious about =Cython=, until now I have been using ~C++ boost~
library in order to write my =Python= wrappers around =C/C++= code. =Cython=
provides a variant of =Python= syntax such as optional static type declarations
(this is not the same as =mypy=) that provides speed improvements when the code
is compiled. Therefore, all the =Cython= code you write is compiled to =.c=
files and then a =C= compiler compiles it to a shared library =.so= which can
be imported directly into the normal =CPython= interpreter. 

In order to be able to compile =Cython= code you will need to write a
distutils/setuptools =setup.py= file. You can read about how to do it [[http://docs.cython.org/en/latest/src/quickstart/build.html][here]].

The next lines are just some emacs packages that will help you to write your
=Cython= code.

#+BEGIN_SRC emacs-lisp
(use-package cython-mode
  :ensure t)

(use-package flycheck-cython
  :ensure t)
#+END_SRC

** Javascript
*** =js-2mode=
Better [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html][Javascript mode]].

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :config

  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (add-hook 'js2-mode-hook #'js2-imenu-extras-mode))
#+END_SRC
** Docker files
Spotify created a mayor mode that provides syntax highlighting as well as the
ability to build the image directly from the buffer with ~C-c C-b~.

Also you can specify the image name in the file itself as in =org-mode=
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html][File-Local Variables]].

#+BEGIN_EXAMPLE
## -*- docker-image-name: "your-image-name-here" -*-
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(use-package docker
  :ensure t
  :init (setq helm-command-prefix-key "C-x M-h")
  :bind ("C-x c" . docker))

(use-package dockerfile-mode
  :ensure t
  :config

  (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

(use-package docker-tramp
  :ensure t)
#+END_SRC

Also =docker-compose-mode= provides syntax highlighting and completions for
=docker-compose= files using company as backend.

#+BEGIN_SRC emacs-lisp
(use-package docker-compose-mode
  :ensure t
  :hook (docker-compose-mode . company-mode))
#+END_SRC

** =LaTeX=
This configuration tries to mimic a WYSIWYG editor in Emacs.

*** =AUCTeX=
Provides features in order to edit, compile and view =TeX= files in Emacs. You
will need to install it from the repositories of your distribution.

In order to get support for many other =LaTeX= packages you have to enable
document parsing. If you also use ~\include~ you also should make =AUCTeX=
aware of the multi-file document structure. Each time you open a new file
=AUCTeX= will ask you for a master file.
 
#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq-default TeX-master nil)
(setq LaTeX-electric-left-right-brace t)
(setq TeX-source-correlate-mode t)
(setq TeX-view-program-selection '(((output-dvi has-no-display-manager) "dvi2tty")
                                   ((output-dvi style-pstricks) "dvips and gv")
                                   (output-dvi "xdvi")
                                   (output-pdf "PDF Tools")
                                   (output-html "xdg-open")))
#+END_SRC

**** Formating functions
Basic keybindings in order to format text.

#+BEGIN_SRC emacs-lisp
(add-hook  'LaTeX-mode-hook
           (lambda ()
             (local-set-key (kbd "C-c f") 'TeX-font)))
#+END_SRC

*** Enable =flyspell= in TeX files
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-buffer)
#+END_SRC

*** Enable =auto-fill= for TeX edition 
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-math-mode-hook 'auto-fill-mode)
#+END_SRC

*** Adding =company= support for TeX
Add the backend enable auto-completion for LaTeX files.

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :ensure t
  :hook (LaTeX-mode . company-mode)
  :config

  (company-auctex-init))
#+END_SRC
   
** =hideshow=
This minor mode provides selectively folding for code and comment
blocks. Blocks are defined per mayor mode. It cames pre-configured with default
mayor modes like =c-mode, c++mode..=

You can configure this minor mode and enable it in different mayor modes with
this config. This [[https://emacs.stackexchange.com/questions/2884/the-old-how-to-fold-xml-question][issue]] explains how to configure for =nxml-mode=.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :ensure t
  :bind ("C-c h" . hs-toggle-hiding)
  :config
  (add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
			   nxml-forward-element
               nil))
)

(add-hook 'nxml-mode-hook 'hs-minor-mode)
(add-hook 'python-mode-hook 'hs-minor-mode)
#+END_SRC
* WIP
These source blocks needs to be moved to its corresponding sections.

#+BEGIN_SRC emacs-lisp
(use-package org-autolist
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))

(use-package org-bullets
  :ensure t)
  ;:config
  ;(progn
  ;  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  ;  (setq org-bullets-bullet-list
  ;        '("\u25c9" "\u25ce" "\u25cb" "\u25cb" "\u25cb" "\u25cb"))))

#+END_SRC

* Org-mode
** Enable =auto-fill-mode=
This conf enables 80 characters auto filling per line inside =org-mode=. I
believe that 80 character per line enhances the readability of a text file.

If you want a visual behaviour inside =emacs= instead into the raw text file
check [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]].

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
(setq-default fill-column 79)
#+END_SRC

** Set the directory
Set the path of the org directory

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Drive/org/")
#+END_SRC

** Setting up the agenda
I'm triying to use the =org= agenda in order to organize all my workflow
tasks. So in this section there are some agenda useful configurations.

First, I'm defining where are my agenda files. I like to have it synced with
Google Drive, in order to have always ready a back up. Also =org= can handle
multiple agenda files, so you can add more files or folder to the list.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list "~/Drive/org/agenda.org"))
#+END_SRC

As I said, I'm planning keep track of my tasks on the agenda. Thus I need to
add some workflow states to the default *TODO* | *DONE* defined on Emacs

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
	  '((sequence "TODO" "IN-PROGRESS" "WAITING" "|" "DONE" "CANCELED")))
#+END_SRC

Also setting this keybinding allows me take quick looks to the agenda by week.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c t a") 'org-agenda-list)
#+END_SRC   

In order to add items to the agenda from anywhere in Emacs, we need to use
=org-capture=. When you call it, a split will prompt asking you to select a
template to use in order to add the task. By default, there are not templates,
so lets define one along with a keybinging to call it.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
	  '(("a" "My TODO task format." entry
		 (file "agenda.org")
		 "* TODO %?
SCHEDULED: %t")))

(defun my-org-task-capture ()
  "Capture a task with my default template."
  (interactive)
  (org-capture nil "a"))

(global-set-key (kbd "C-c c c") 'my-org-task-capture)
#+END_SRC

Also, I want an easy way to add tasks from the agenda view. So lets bound the =c= key
to the default capture command. In addition, pressing =C-u c= will open the
default =org-capture= dialog prompting the different capture types.

The key binding is set in [[ref:sec:agenda-key-bindings][Agenda key bindings]] section.

#+BEGIN_SRC emacs-lisp
(defun my-org-agenda-capture (&optional vanilla)
  "Capture a task in agenda mode, using the date at point.

If VANILLA is non-nil, run the standard `org-capture'."
  (interactive "P")
  (if vanilla
      (org-capture)
    (let ((org-overriding-default-time (org-get-cursor-date)))
      (org-capture nil "a"))))
#+END_SRC

Finally, I want to see my daily agenda as I defined in my custom view in the
section [[ref:sec:agenda-custom-commands][Agenda custom commands]]. So, as I take quick looks to the daily agenda
the =S-SPC= binding fits perfect.

#+BEGIN_SRC emacs-lisp
(defun my-pop-to-org-agenda (&optional split)
  "Visit the org agenda, in the current window or a SPLIT."
  (interactive "P")
  (org-agenda nil "d")
  (when (not split)
    (delete-other-windows)))

(global-set-key (kbd "S-SPC") 'my-pop-to-org-agenda)
#+END_SRC

Below these lines, there are some tweaks that I've found for the agenda.

Performing a text search ("s" selection from =org-agenda=) include all the text
from the file list in =org= agenda.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-text-search-extra-files '(agenda-archives))
#+END_SRC

This option force you to mark all child tasks as *DONE* before you can mark the
parent as *DONE*.

#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

This one insert a timestamp on the task when it was marked as done. Very useful
in order to maintain a log of when the tasks are done. Also the same idea, but
for logging how many the times a deadline or an scheduled date was changed.

#+BEGIN_SRC emacs-lisp
(setq org-log-done (quote time))
(setq org-log-redeadline (quote time))
(setq org-log-reschedule (quote time))
#+END_SRC

*** Agenda key bindings
:PROPERTIES:
:CUSTOM_ID: sec:agenda-key-bindings
:END:

In this section are all the key bindings related to the agenda mode. They need
to be evaluated after the =org-agenda-mode= was loaded, otherwise =Emacs= would
fail to evaluate them.

- Rebind the =k= and =j= keys to move up and down as in =evil-mode=.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-agenda
  '(progn
	 (define-key org-agenda-mode-map "j" 'org-agenda-next-item)
	 (define-key org-agenda-mode-map "k" 'org-agenda-previous-item)
	 (define-key org-agenda-mode-map "c" 'my-org-agenda-capture)))
#+END_SRC

** Agenda custom commands
:PROPERTIES:
:CUSTOM_ID: sec:agenda-custom-commands
:END:
This custom commands are intended to define my custom view of the agenda. All
the ideas are inspired on [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][this Aaron Bieber]] blog entry.

The defined agenda view shows the tasks for today, along with the high priority
and all that aren't scheduled for any date.

#+BEGIN_SRC emacs-lisp
(defun my-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun my-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(setq org-agenda-custom-commands
      '(("d" "Daily agenda and all TODOs"
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))
          (agenda "" ((org-agenda-span 1)))
          (alltodo ""
                   ((org-agenda-skip-function '(or (my-org-skip-subtree-if-habit)
                                                   (my-org-skip-subtree-if-priority ?A)
                                                   (org-agenda-skip-if nil '(scheduled deadline))))
                    (org-agenda-overriding-header "ALL normal priority tasks:")))))))
#+END_SRC

** =evil= integration with =org-mode=
I'm very used to =Vim=, that's why I use =evil-mode=. But, it doesn't have a
default integration with =org-mode=. That's where =evil-org= package helps defining some useful
keybindings for a =Vim= key-map fan.

#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t
  :hook (org-mode . evil-org-mode))
#+END_SRC
** Native =TAB= in source blocks
By default =TAB= keystroke doesn't indent in =org= source blocks. Typing
=C-q-<TAB>= I can force a native =TAB= but I prefer this option that makes
=TAB= work as if the keystroke was issued in the code’s major mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

** =org-ref=
This is an =org-mode= module to handle citations, cross-references and
bibliographies.

We require the packages and set the default for the bibliography notes, the
main .bib bibliography and the directory where the PDFs can be downloaded to.

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t
  :config

  (setq org-src-preserve-indentation t)

  (setq org-latex-default-packages-alist
	(-remove-item
	 '("" "hyperref" nil)
	 org-latex-default-packages-alist))

  (add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
  (add-to-list 'org-latex-default-packages-alist
	       '("linktocpage,pdfstartview=FitH,colorlinks,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=blue,menucolor=black,urlcolor=blue"
		 "hyperref" nil)
	       t)

  (progn
    (setq org-ref-bibliography-notes "~/Drive/org/bibliography/notes.org"
          org-ref-default-bibliography '("~/Drive/org/bibliography/main.bib")
          org-ref-pdf-directory "~/Drive/org/bibliography/pdfs"
          org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))

  (setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5))
#+END_SRC

This enable the use of native =org-mode= labels in =org-ref= links, instead the
~label:org-ref~ style.

#+BEGIN_SRC emacs-lisp
(setq org-latex-prefer-user-labels t)
#+END_SRC
** IEEE export
For class assignments and who-knows-what in the future, I was able to integrate
a IEEE Conference template in org-mode export via Latex. To use it, just
include the IEEEtran class in your org file. It has not been thoroughly tested,
but its headers, index, abstract and general aesthetic works perfectly out of
the box.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
             t)
#+END_SRC

** Beamer export
We need to manually enable the export to Beamer option

#+BEGIN_SRC emacs-lisp
(use-package ox-beamer)
#+END_SRC

** Custom ellipsis
Custom ellipsis to use in the =org-mode= heading outline.
   
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " \u2935")
#+END_SRC
** Prettify symbols
This setting will prettify latex symbols like (~x_{subscript}~) and
superscripts (~x^{superscript}~). As a consequence, they will appear in =org=
as visual symbols.
   
#+BEGIN_SRC emacs-lisp
(setq-default org-pretty-entities t)
#+END_SRC
** =org-download=
Thanks to [[https://github.com/abo-abo/org-download][org-download]] you are able to drag and drop images to Emacs
=org-mode=. There are several sources image cames from: From browser, file
system, remote address using ~org-download-yank~ or a screenshot using
~org-download-screenshot~.

#+BEGIN_SRC emacs-lisp
(require 'org-download)

(add-hook 'dired-mode-hook 'org-download-enable)
#+END_SRC
   
** Use syntax highlight in source blocks
When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

** Source syntax highlight in =latex= exports
Using =org-mode= =latex= export you can get syntax highlighting in pdf using
the =minted= package, wich uses =Python= =pygments= package. This snippet was
taken from [[http://joonro.github.io/blog/posts/org-mode-outputdir-minted-latex-export.html][Joon's Blog]]. [[https://github.com/gpoore/minted/issues/92][Issue]] ~cache=false~.

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("cache=false" "minted"))
(setq org-latex-listings 'minted)
#+END_SRC

** Auto cleanup =latex= intermediary files
I hate all this intermediary files that =latex= creates. Just blow up all my
directories. So, I've found a solution in this [[https://emacs.stackexchange.com/questions/23982/cleanup-org-mode-export-intermediary-file][emacs stack exchange question]].

#+BEGIN_SRC emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl")))
#+END_SRC

** Time tracking: Clocking
I've recently discovered this feature and is awesome. It enables time tracking
for tasks inside an agenda file.

~C-c C-x C-i~ Starts the clock on the current time
~C-c C-x C-o~ Stops the current active clock

With this option all the =CLOCKS= will be grouped into a =:CLOCKING:= entry

#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
#+END_SRC

* Other major modes
** Evil mode
I'm very used to =Vim= and prefer its keybindings over the Emacs
ones. =Evil-mode= provides keybindings and emulates the main features of =Vim=.

This configuration enables leader key function and highlihgt persistence on
searches.
   
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :config

  (evil-mode 1)

  ;; Evil key bindings
  (define-key evil-motion-state-map "j" 'evil-next-visual-line)
  (define-key evil-motion-state-map "k" 'evil-previous-visual-line)

  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)

    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "x" 'counsel-M-x
      "<SPC>" 'evil-search-highlight-persist-remove-all
	  "i" 'counsel-imenu))

  (use-package evil-search-highlight-persist
   :ensure t
   :config
   (global-evil-search-highlight-persist t))

	;; Add these evil keybindings in Emacs mode
	(evil-add-hjkl-bindings occur-mode-map 'emacs
	(kbd "/")       'evil-search-forward
	(kbd "n")       'evil-search-next
	(kbd "N")       'evil-search-previous
	(kbd "C-d")     'evil-scroll-down
	(kbd "C-u")     'evil-scroll-up
	(kbd "C-w C-w") 'other-window))
#+END_SRC

** =mu4e=
=mu= is a simple command line tool for searching through emails. It's a cute
little tool and is especially nice for allowing you to quickly check for any
new email without leaving the terminal. However, you need to have an offline
copy of the messages where =mu= can search. This is done through
=offlineimap=. You can find how is configured in my [[https://github.com/labellson/dotfiles][dotfiles]] repository.

=mu4e= is the Emacs email client included with =mu=. It provides functionality
to search over the offline copy of my emails, move them around, and send/reply
to different mail servers.

For sending mail using SMTP, =mu4e= uses =smtpmail= in order to establish the
connection to the SMTP server. The authentication is done using [[https://www.gnu.org/software/emacs/manual/html_node/auth/index.html#Top][auth-source]]
library.

As [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/#pitfalls-and-additional-tweaks][Gregory J Stein]] points, =offlineimap= won't sync the messages sended to the
trash marked with the *T* label, which happens  whenever you delete a message
with *d*. The workaround is the last function defined in the below snippet.

Activating [[http://www.djcbsoftware.nl/code/mu/mu4e/Org_002dmode-links.html#Org_002dmode-links][org-mu4e]] you will be able to capture links or queries to your emails
and then use it as links into your =org-mode= files. Very handy if you want to
store emails into the agenda file.

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :load-path "/usr/share/emacs/site-lisp/mu4e"
  :demand t
  :bind (("C-c m" . mu4e))
  :hook (mu4e-compose-mode . flyspell-mode)
  :config

  (require 'org-mu4e)
  (require 'shr)

  ;; Set mu4e as default mail user agent
  (setq mail-user-agent 'mu4e-user-agent)
  
  ;; Set the default Maildir folders
  (setq mu4e-maildir "~/.maildir"
		mu4e-sent-folder "/fastmail/Sent"
		mu4e-drafts-folder "/fastmail/Drafts"
		mu4e-trash-folder "/fastmail/Trash"
		mu4e-refile-folder "/fastmail/Archive"
		mu4e-completing-read-function 'ivy-completing-read
		mu4e-confirm-quit nil
		mu4e-kill-buffer-on-exit t
		smtpmail-stream-type 'ssl
		smtpmail-smtp-server "smtp.fastmail.com"
		smtpmail-smtp-service 465)

  (setq send-mail-function 'smtpmail-send-it
		message-send-mail-function 'smtpmail-send-it)

  (setq	mu4e-view-date-format "%a %e %b %Y %T"
		mu4e-headers-date-format "%d/%m/%Y"
		mu4e-headers-time-format "%T"
		mu4e-view-prefer-html t
		shr-use-colors nil
		shr-use-fonts nil
		shr-width 79)

  (setq mu4e-bookmarks
		`( ,(make-mu4e-bookmark
			 :name  "Unread messages"
			 :query "flag:unread AND NOT flag:trashed AND NOT maildir:/fastmail/Spam"
			 :key ?u)
		   ,(make-mu4e-bookmark
			 :name "Today's messages"
			 :query "date:today..now"
			 :key ?t)
		   ,(make-mu4e-bookmark
			 :name "Last 7 days"
			 :query "date:7d..now"
			 :key ?w)
		   ,(make-mu4e-bookmark
			 :name "Inbox"
			 :query "maildir:/fastmail/INBOX"
			 :key ?i))))
#+END_SRC

As I use =evil-mode=, lets enable =vim-like= keystrokes inside =mu4e=.

#+BEGIN_SRC emacs-lisp
(use-package evil-mu4e
  :ensure t)
#+END_SRC

Thanks to =mu4e-alert= whenever you call ~mu4e-alert-enable-mode-line-display~,
your modeline will be updated to include a little envelope icon and the current
count of unread messages.

#+BEGIN_SRC emacs-lisp
(use-package mu4e-alert
  :ensure t
  :after mu4e
  :hook (after-init . mu4e-alert-enable-mode-line-display)
  :config

  (mu4e-alert-set-default-style 'libnotify)
  (setq mu4e-alert-interesting-mail-query
		"flag:unread AND NOT flag:trashed AND NOT maildir:fastmail/Spam")

  (setq mu4e-alert-modeline-formatter
		'mu4e-alert-custom-mode-line-formatter)

  (defun mu4e-alert-custom-mode-line-formatter (mail-count)
	"Custom formatter used to get the string to be displayed in the
mode-line.Uses Font Awesome mail icon to have a more visual icon
in the display.  MAIL-COUNT is the count of mails for which the
string is to displayed"
	(when (not (zerop mail-count))
      (concat " "
              (propertize
               ""
               ;; 'display (when (display-graphic-p)
               ;;            display-time-mail-icon)
               'face display-time-mail-face
               'help-echo (concat (if (= mail-count 1)
                                      "You have an unread email"
									(format "You have %s unread emails" mail-count))
                                  "\nClick here to view "
                                  (if (= mail-count 1) "it" "them"))
               'mouse-face 'mode-line-highlight
               'keymap '(mode-line keymap
                                   (mouse-1 . mu4e-alert-view-unread-mails)
                                   (mouse-2 . mu4e-alert-view-unread-mails)
                                   (mouse-3 . mu4e-alert-view-unread-mails)))
              (if (zerop mail-count)
                  " "
				(format " [%d] " mail-count))))))
#+END_SRC

Also, I define a custom function so that updating the mail is possible just by pinging the Emacs daemon. I have this function called as a post-hook every time the offlineimap is called.

#+BEGIN_SRC emacs-lisp
(defun update-mail-in-server ()
  "Check for mail and update the mode line icon."
  (interactive)
  (mu4e-update-mail-and-index t)
  (mu4e-alert-enable-mode-line-display)
  ;; Clear echo area in 2 seconds after update
  (run-with-timer 2 nil (lambda () (message nil))))
#+END_SRC

* Packages & Tools
** =which-key=
A useful package that displays the possible key combinations when you start a
new key command.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode))
#+END_SRC
** Add icons with =all-the-icons=
This package comes with a set of icons for Emacs. You have to install them with
~all-the-icons-install-fonts~

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

** Add emojis to emacs
=emojify= will display emojis as images, so your emacs should be compiled with
support for *PNG* images in order to display it properly. But if you have
installed an emoji font is also a good idea to turn on the unicode display of
emojis.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :ensure t
  :hook (after-init . global-emojify-mode)
  :config

  (setq emojify-emoji-styles '(unicode github)))
#+END_SRC

** =dired=
This is the default Emacs system directory. It's super useful, specially when
I'm in some OS where I don't feel very confortable :P Dired allows you
navigation through the filesystem using a text buffer. That's very useful
because if you press =C-x C-q= in the dired buffer it turns into a writeable
buffer so you can edit files or directories as a regular textfile. Setting to
true ~dired-dwin-target~ enables the dired Do What I Mean behaviour. With that,
if you try to rename a file with a second buffer open, it will asume that you
want to move it there. Same with copy and other operations.

In this [[https://www.youtube.com/watch?v=7jZdul2fC94][video]] you can see a reference of what you can do with =dired= mode.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook (dired-mode . dired-hide-details-mode)
  :config
  (setq dired-dwim-target t))

(if (not '(system-is-windows))
	(use-package all-the-icons-dired
	  :ensure t
	  :hook (dired-mode . all-the-icons-dired-mode)))

(use-package dired-sidebar
  :ensure t
  :bind (("C-c s" . dired-sidebar-toggle-sidebar)))
#+END_SRC

** Move buffers around
There's no fast way to swap buffers location in Emacs by default. To do it, a
good option is to use =buffer-move= package and use these key bindings.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-x w <up>"    . buf-move-up)
		 ("C-x w <down>"  . buf-move-down)
		 ("C-x w <left>"  . buf-move-left)
		 ("C-x w <right>" . buf-move-right)
		 ("C-x w k"       . buf-move-up)
		 ("C-x w j"       . buf-move-down)
		 ("C-x w h"       . buf-move-left)
		 ("C-x w l"       . buf-move-right)))
#+END_SRC

** Relative margin line numbers
This setting enables the margin line numbers with the relative number mode.
 
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
  :ensure t
  :hook (prog-mode . nlinum-relative-mode)
  :config

  (nlinum-relative-setup-evil)
  (setq nlinum-relative-redisplay-delay 0))
#+END_SRC
** Zsh like completion
=zlc= provides Zsh like completion for the default minibuffer.

#+BEGIN_SRC emacs-lisp
;; Zsh Tab completion for minibuffer
(use-package zlc
  :ensure t
  :config
  (zlc-mode t))
#+END_SRC
** Environment variables
Emacs doesn't look to my user environment variables. Therefore, I can't get
python completion working with my own modules because it doesn't look for my
~$PYTHONPATH~. =exec-path-from-shell= is an Emacs library to ensure variables
inside Emacs look the same as in the user's shell. By default it sets the user
~$MANPATH~ and ~$PATH~. Also you can copy other environment variables by
customizing ~exec-path-from-shell-variables~ or by calling
~exec-path-from-shell-copy-env~.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :config

  (add-to-list 'exec-path-from-shell-variables '"PYTHONPATH")
  (add-to-list 'exec-path-from-shell-variables '"GTAGSLIBPATH")
  (exec-path-from-shell-initialize))
#+END_SRC

** Spell checking
Emacs comes with =ispell= a very useful spell checker if you use emacs to write
notes or documents as I do. =ispell= needs a completion tool to review the
text. I've installed  =hunspell= in my Arch Linux laptop.

I set spanish as default language for spell checking because is my native
language. But, I can use =M-x ispell-change-dictionary= if I want to change the
spell checking language.

The last two lines prevents =ispell= to check inside =org= source blocks and
sections.
   
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :hook (org-mode .(lambda() (setq ispell-parser 'tex)))
  :config

  (when (executable-find "aspell")
	(setq ispell-program-name "aspell")
	(setq ispell-dictionary "espanol"))

  (set-face-underline 'flyspell-incorrect
					  '(:color "#dc322f" :style line))
  (set-face-underline 'flyspell-duplicate
					  '(:color "#e5aa00" :style line))

  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC")))
#+END_SRC
** =ivy=
=ivy= is a minimalistic completion engine. It supports fuzzy matching. But I
don't like this behaviour on =swiper= search engine. So, I deactivated setting
the default regexp builder with ~(swiper . ivy--regex-plus)~.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :demand t
  :config

  (ivy-mode) 
  (setq ivy-use-virtual-buffers t
		ivy-count-format "%d/%d ")

  (setq ivy-wrap t)

  ; Fuzzy mode
  (setq ivy-re-builders-alist
		'((swiper . ivy--regex-plus) ; No Fuzzy matchin for swiper
		  (t      . ivy--regex-fuzzy)))

  (setq ivy-initial-inputs-alist nil)

  :bind (("C-s" . swiper)
		 :map ivy-minibuffer-map
		 ("RET" . ivy-alt-done)
		 ("C-j" . ivy-next-line)
		 ("C-k" . ivy-previous-line))) 
#+END_SRC

Also, this alternative package complement =ivy=

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :ensure t
  :demand t
  :config (ivy-rich-mode))
#+END_SRC

=counsel= is collection of Ivy-enhanced versions of common Emacs commands. So,
enhances the emacs user experience ;)

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :demand t) 
#+END_SRC

=swiper= is an Ivy-enhanced alternative to isearch

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :demand t)
#+END_SRC

** =projectile=
Enables different tools and functions to deal with files related to a
project. It works out of the box, since it will detect your *VCS* files
automatically and set it as the root of the project. If it doesn't, you can
just create an empty =.projectile= file in the root of your project.

I have it configured to ignore all files that has not been staged in the
project.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config

  (projectile-global-mode t)
  (setq projectile-use-git-grep t)

  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+END_SRC

Also, the =counsel-projectile= extension adds integration with =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :config (counsel-projectile-mode t))
#+END_SRC
** =flycheck=
=Flycheck= brings on-the-fly syntax checking for different languages. It comes
already with support for a lot of languages and can also use other packages as
backend.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :hook (prog-mode . flycheck-mode)
  :config

  (set-face-underline 'flycheck-error '(:color "Red1" :style line))
  (set-face-underline 'flycheck-warning '(:color "#e5aa00" :style line))
  (set-face-underline 'flycheck-info '(:color "#268bd2" :style line)))
#+END_SRC

** =smartparens=
Auto-close parenthesis and other characters. Very useful in =prog-mode=.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config

  (add-hook 'prog-mode-hook #'smartparens-mode)
  (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
#+END_SRC
** Smooth scrolling
This package keeps the cursor away from the top and bottom of the current
buffer's window in order to keep lines of context around the point visible as
much as possible.

#+BEGIN_SRC emacs-lisp
; Smooth scrolling on file limits
(use-package smooth-scrolling
  :ensure t
  :config
  (smooth-scrolling-mode 1))
#+END_SRC
** Clipboard integration
=simple-clip= enables clipboard system integration from emacs.
   
#+BEGIN_SRC emacs-lisp
; SimpleClip Super+C Super+X Super+V
(use-package simpleclip
  :ensure t
  :config
  (simpleclip-mode 1))
#+END_SRC

** PDF Tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config

  (pdf-tools-install))

#+END_SRC
  
There's a conflict between =evil-mode= and =pdf-view-mode=. =evil= cause that
pdf display keeps blinking. [[https://github.com/politza/pdf-tools/issues/201][xuhdev]] gives a solution to deal with this conflict.

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'pdf-view-mode 'emacs)
(add-hook 'pdf-view-mode-hook
  (lambda ()
    (set (make-local-variable 'evil-emacs-state-cursor) (list nil))))
#+END_SRC
* Acknowledgments
- Thanks to Diego Vicente. He discovered me Emacs and =org-mode=. Also, many
  aspects of my Emacs file are inspired by his [[https://github.com/DiegoVicen/my-emacs][config file]].
