#+TITLE: My Emacs Config
#+AUTHOR: Daniel Laguna
#+EMAIL: labellson@gmail.com

* Introduction
The idea of generating an emacs config file using =org-mode= is taken from
[[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs starts, all the elisp code
blocks from this file are parsed and used to generate the config. This is done
through [[http://orgmode.org/worg/org-contrib/babel/][org-babel]]. =Babel= is Org-mode's ability to execute source code within
=org-mode= documents.

To use this config file, you need to evaluate this file on startup. This can be
done writing this line ~(org-babel-load-file "~/.my-emacs/README.org")~ into
your [[file:init.el][init.el]].

*NOTE*: This file assumes that your =org-mode= config file is located into
=~/.my-emacs/README.org=.

* Basic Emacs Setup
** My information
Relevant personal information that Emacs needs.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Laguna"
    user-mail-address "labellson@gmail.com"
    calendar-latitude 40.33
    calendar-longitude -3.76
    calendar-location-name "Madrid, Spain")
#+END_SRC

** Adding MELPA 
MELPA is the main package repository for Emacs. There are more repositories and
you are able to add more than one. *But make sure you are using HTTPS!!*.

#+BEGIN_SRC emacs-lisp
;; Set up the package manager and repositories
(require 'package)

(add-to-list 'package-archives '("MELPA" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))

(setq package-enable-at-startup nil)
(package-initialize)
#+END_SRC

** Install ~use-package~
Emacs has a built-in package manager that makes easy to install
packages. =use-package= makes things easier though. As a consequence, I need to
write less ~emacs-lisp~ code, and along with =org-mode=, it makes easier the
maintenance of a configuration file.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
#+END_SRC

** TAB
=<TAB>= key run indentation in most of the major mode. Sometimes, I want to
=<TAB>= behaves as inserting a tab character. I can do this typing =C-q-<TAB>=
but I don't like the default widht. So...

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

** Disable =yes-or-no= messages
There are different types of confirmation prompts in Emacs. One of them forces
you to write =yes= and the other one only to press =y=, so I disable the first
type.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disabling the default startup message
I prefer to have a scratch buffer ready when booting up with =org-mode= running

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
	  initial-scratch-message nil
	  initial-major-mode 'org-mode)
#+END_SRC

** Disable the warning when killing a buffer with process
When a buffer has an associated process, Emacs will prompt you when trying to
kill it asking for confirmation. I preferred to disable this behaviour.

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
	  (remq 'process-kill-buffer-query-function
			 kill-buffer-query-functions))
#+END_SRC

** Fix scroll
Setting this values will force one-line scrolling everywhere (mouse and
keyboard), resulting most of the times in a smoother scrolling than the actual
smooth scolling.

#+BEGIN_SRC emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000
	  mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't)
#+END_SRC

** Set the backups folder
Backups are always fancy. But emacs, blows up all my project folders with
swarms of =#foo#= files. That's why I set them to a backup folder and stop them
from polluting everywhere.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
	  backup-by-copying t
	  version-control t
	  delete-old-versions t
	  kept-new-versions 20
	  kept-old-versions 5)
#+END_SRC

** Auto-fill comments
For our comments (only comments, not code) to be automatically filled in
programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** Increase or decrease font size across all buffers
Extracted from a file in [[https://github.com/purcell/emacs.d][Steve Purcellâ€™s Emacs configuration]], it is possible to
use this functions to increase or decrease the text scale in all
Emacs. Specially useful for presentations, demos and other shows alike.

#+BEGIN_SRC emacs-lisp
(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

** Add functions to determine system 
One liner functions to know in which system we are running.

#+BEGIN_SRC emacs-lisp
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))

(defun system-is-chip ()
  (interactive)
  (string-equal system-name "chip"))

(defun system-is-windows ()
  (interactive)
  (or (string-equal system-name "windows-nt")
	  (string-equal system-name "cygwin")))
#+END_SRC

** Define keybindings to =eval-buffer= on init and open =README.org=
Really loving this emacs =org-mode= configuration. It was easier to reload the
configuration on the fly: ~M-x eval-buffer RET~. However the buffer to evalute
is not this one, but =.emacs.d/init.el=. That's whu it's probably a better idea
to define a new keybinding that automatically reloads that buffer.

#+BEGIN_SRC emacs-lisp
(defun reload-emacs-configuration ()
  "Reload the configuration"
  (interactive)
  (load "~/.emacs.d/init.el"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
  (find-file "~/.my-emacs/README.org"))

(global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
(global-set-key (kbd "C-c c o") 'open-emacs-configuration)
#+END_SRC

** Scroll in the compilation buffer
It's really annoying to not have the last part of the output in the screen when
compiling. This automatically scrolls the buffer for you as the output is printed.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

** Add other keybindings
In this section goes all these keybindings that don't really fit anywhere else.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c b") 'bookmark-jump)
#+END_SRC
* Emacs GUI
** Highlight changed and uncommited lines
Use the =git-gutter-fringe= package for that. I have it activated for
=prog-mode= and =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :ensure t
  :config

  (add-hook 'prog-mode-hook 'git-gutter-mode)
  (add-hook 'org-mode-hook  'git-gutter-mode))
#+END_SRC

** Setting solarized theme
I've been using =grubvox= dark theme for a long time on =vim= and in my firsts
steps with =emacs=. But, I've always been in love with =solarized-light=. On my
opinion, =solarized= doesn't looks pretty on =vim=. But looks sexy on =emacs=.

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :ensure t
  :init
  (setq solarized-use-variable-pitch nil)
  :config
  (load-theme 'solarized-light t)
  (set-face-attribute 'org-block nil :background "#f9f2d9"))
#+END_SRC

** Mode-line configuration
These two packages developed by [[https://github.com/tarsius][Jonas Bernoulli]], provide a beautiful and simple
mode-line that shows all the information in a beautiful and minimalistic way.
The general mode-lin aesthetics and distribution is provided by =moody=, while
=minions= hide all the minor modes and provides an on-click menu to show
them. So, I don't need anymore the delight package to hide all the actually
active minor modes.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :ensure t
  :config

  (setq minions-mode-line-lighter "[+]")
  (minions-mode))

(use-package moody
  :ensure t
  :config

  (setq x-underline-at-descent-line t
		column-number-mode t)

  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)

  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))
#+END_SRC

* Programming Modes
** =company=
[[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

Add =company-tng-frontend= if you like YCM Vim completion :P

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
    (setq company-tooltip-align-annotations t)
    (eval-after-load 'company
      '(progn
        (add-hook 'prog-mode-hook 'company-mode)
        (add-to-list 'company-frontends 'company-tng-frontend)
        (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
        (define-key company-active-map [tab] 'company-complete-common-or-cycle)
        (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
        (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
        
        (define-key company-mode-map (kbd "C-<SPC>") 'company-complete))))
#+END_SRC

With =company-flx= we add fuzzy matching to =company=. But it seems only work
with =company-capf= backend.

#+BEGIN_SRC emacs-lisp
(use-package company-flx
  :ensure t
  :config
    (eval-after-load 'company
      (company-flx-mode +1)))
#+END_SRC
   
** C/C++
I've been using *NeoVim* with =YouCompleteMe= for C/C++ development. But, I
want to change my default text editor to emacs. So, this section sums up my
research on C/C++ related emacs packages. 

** =emacs-ycmd=
I've been testing =rtags= and =irony= modes, but I could not properly
configurate. But, I've seen there's a client for =ycmd= on emacs too.

=emacs-ycmd= is an emacs mode that takes care of managing a ycmd server and
fetching completions from that server for offer some IDE-like functionality for
C/C++.

In order to use this package the [[https://github.com/Valloric/ycmd][ycmd]] server must be compiled. For C/C++
completion: ~./build.py --clang-completion~.

#+BEGIN_SRC emacs-lisp
(use-package ycmd
  :ensure t
  :config

  (set-variable 'ycmd-server-command `("python3",
									   (file-truename "~/.ycmd/ycmd")))
  (set-variable 'ycmd-global-config (expand-file-name "~/.ycmd/.ycm_extra_conf.py"))

  (add-hook 'c++-mode-hook #'ycmd-mode)
  (add-hook 'ycmd-mode-hook 'ycmd-eldoc-setup))
#+END_SRC

To enable code completion with company install the backend.

#+BEGIN_SRC emacs-lisp
(use-package company-ycmd
  :ensure t
  :config

  (company-ycmd-setup)

  (eval-after-load 'company
	'(add-to-list 'company-backends 'company-ycmd)))
#+END_SRC

For live code checking =flycheck-ycmd= must be installed.

#+BEGIN_SRC emacs-lisp
(use-package flycheck-ycmd
  :ensure t
  :config

  (flycheck-ycmd-setup)

  (add-hook 'ycmd-mode-hook 'flycheck-ycmd-setup))
#+END_SRC

** Python
In order to use ipython as default interpreter set these lines below.

#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython"
       python-shell-interpreter-args "--simple-prompt -i")
#+END_SRC

I've set a global =tab-width= in basic emacs setup. But it seems not working in
=python-mode=.

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
      (lambda ()
        (setq tab-width 4)))
#+END_SRC

*** =anaconda-mode=
[[https://github.com/proofit404/anaconda-mode][Anaconda]] provides context code completion, jump to definitions, find references
and documentation view through =eldoc= for python mode. Its usage is very
simple and it integrates with =company-mode=.

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :ensure t
  :config
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
#+END_SRC

**** Default Keybinding
| Keybinding | Description                    |
|------------+--------------------------------|
| C-M-i      | anaconda-mode-complete         |
| M-.        | anaconda-mode-find-definitions |
| M-,        | anaconda-mode-find-assignments |
| M-r        | anaconda-mode-find-references  |
| M-*        | anaconda-mode-go-back          |
| M-?        | anaconda-mode-show-doc         |
   
*** =company-anaconda=
This is a backend for =company-mode= that works with =anaconda-mode=. Necessary
if you want autocompletion.

#+BEGIN_SRC emacs-lisp
(use-package company-anaconda
  :ensure t
  :config

    (eval-after-load "company"
      '(add-to-list 'company-backends '(company-anaconda :with company-capf))))
#+END_SRC

*** Package for Python docstrings
This package adds some nice features like automatic creation of docstrings and
highlighting in them. There is also another package for better highlight and
indentation of the comments.

#+BEGIN_SRC emacs-lisp
(use-package sphinx-doc
  :ensure t
  :hook (python-mode . sphinx-doc-mode))

(use-package python-docstring
  :ensure t
  :config (setq python-docstring-sentence-end-double-space nil)
  :hook (python-mode . python-docstring-mode))
#+END_SRC

*** Jupyter Notebook
=EIN= provides a client for =IPython= and =Jupyter= notebooks inside
emacs. This allows use all the emacs features inside the notebooks.

#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t
  :hook (ein:notebook-multilang-mode
		 . (lambda () (ws-butler-mode -1) (visual-line-mode)))
  :custom-face
  (ein:cell-input-area ((t (:background "#f9f2d9")))))
#+END_SRC
** Javascript
*** =js-2mode=
Better [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html][Javascript mode]].

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :config

  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (add-hook 'js2-mode-hook #'js2-imenu-extras-mode))
#+END_SRC
** =hideshow=
This minor mode provides selectively folding for code and comment
blocks. Blocks are defined per mayor mode. It cames pre-configured with default
mayor modes like =c-mode, c++mode..=

You can configure this minor mode and enable it in different mayor modes with
this config. This [[https://emacs.stackexchange.com/questions/2884/the-old-how-to-fold-xml-question][issue]] explains how to configure for =nxml-mode=.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :ensure t
  :bind ("C-c h" . hs-toggle-hiding)
  :config
  (add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>"
               "-->\\|</[^/>]*[^/]>"

               "<!--"
			   nxml-forward-element
               nil))
)

(add-hook 'nxml-mode-hook 'hs-minor-mode)
(add-hook 'python-mode-hook 'hs-minor-mode)
#+END_SRC
* WIP
These source blocks needs to be documented.

#+BEGIN_SRC emacs-lisp


;; Show Parenthesis Mode
(setq show-paren-delay 0)
(show-paren-mode 1)

;; Hide the toolbar and menubar
(tool-bar-mode -1)
(menu-bar-mode -1)

;; Don't create backups
(setq make-backup-files nil)

;; Disable scroll bar
(scroll-bar-mode -1)

;; Load packages
(use-package evil
  :ensure t
  :config
  (evil-mode 1)

  ;; Evil key bindings
  (define-key evil-motion-state-map "j" 'evil-next-visual-line)
  (define-key evil-motion-state-map "k" 'evil-previous-visual-line)

  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)

    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "x" 'counsel-M-x
      "<SPC>" 'evil-search-highlight-persist-remove-all
	  "i" 'counsel-imenu))

  (use-package evil-search-highlight-persist
   :ensure t
   :config
   (global-evil-search-highlight-persist t)))

; Smooth scrolling on file limits
(use-package smooth-scrolling
  :ensure t
  :config
  (smooth-scrolling-mode 1))

; SimpleClip Super+C Super+X Super+V
(use-package simpleclip
  :ensure t
  :config
  (simpleclip-mode 1))

(use-package fill-column-indicator
  :ensure t
  :config
  ;(fci-mode)           ;activate fill-column-indicator. use lambda hook
  (set-fill-column 80))

;; Wrap lines
(global-visual-line-mode 1)

;; Show margin line numbers
(use-package nlinum
  :ensure t
  :config

  ;(global-nlinum-mode t)

  (use-package nlinum-relative
    :ensure t
    :config
   ;; something else you want
    (nlinum-relative-setup-evil)
    (setq nlinum-relative-redisplay-delay 0)
    (add-hook 'prog-mode-hook 'nlinum-relative-mode)))

(use-package linum-off
  :ensure t
  ;(setq linum-disabled-modes-list â€˜(eshell-mode wl-summary-mode compilation-mode))
)

;; Zsh Tab completion for minibuffer
(use-package zlc
  :ensure t
  :config
  (zlc-mode t))

;; Spell checker
(when (executable-find "hunspell")
  (setq-default ispell-program-name "hunspell")
  (setq ispell-dictionary "es_ES")
  (setq ispell-really-hunspell t))

;; Word Count
(use-package wc-mode
  :ensure t
  :config)

;; org-mode

;; Folding character
(setq org-ellipsis " \u2935")

;; Prettify latex symbols
(setq-default org-pretty-entities t)

(use-package org-ref
  :ensure t
  :config

  (setq org-src-preserve-indentation t)

  (setq org-latex-default-packages-alist
	(-remove-item
	 '("" "hyperref" nil)
	 org-latex-default-packages-alist))

  (add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
  (add-to-list 'org-latex-default-packages-alist
	       '("linktocpage,pdfstartview=FitH,colorlinks,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=blue,menucolor=black,urlcolor=blue"
		 "hyperref" nil)
	       t)

  (progn
    (setq org-ref-bibliography-notes "~/Drive/org/bibliography/notes.org"
          org-ref-default-bibliography '("~/Drive/org/bibliography/main.bib")
          org-ref-pdf-directory "~/Drive/org/bibliography/pdfs"
          org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))

  (setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5))

(use-package org-autolist
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))

;; Set the agenda files
(setq org-agenda-files (list "~/Drive/org/agenda.org"))

(use-package org-bullets
  :ensure t)
  ;:config
  ;(progn
  ;  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  ;  (setq org-bullets-bullet-list
  ;        '("\u25c9" "\u25ce" "\u25cb" "\u25cb" "\u25cb" "\u25cb"))))

;; Add these evil keybindings in Emacs mode
(evil-add-hjkl-bindings occur-mode-map 'emacs
  (kbd "/")       'evil-search-forward
  (kbd "n")       'evil-search-next
  (kbd "N")       'evil-search-previous
  (kbd "C-d")     'evil-scroll-down
  (kbd "C-u")     'evil-scroll-up
  (kbd "C-w C-w") 'other-window)

;; Keyboard maps
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC

* Org-mode
** Enable =auto-fill-mode=
This conf enables 80 characters auto filling per line inside =org-mode=. I
believe that 80 character per line enhances the readability of a text file.

If you want a visual behaviour inside =emacs= instead into the raw text file
check [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]].

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
(setq-default fill-column 79)
#+END_SRC

** =evil= integration with =org-mode=
I'm very used to =Vim=, that's why I use =evil-mode=. But, it doesn't have a
default integration with =org-mode=. That's where =evil-org= package helps defining some useful
keybindings for a =Vim= key-map fan.

#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :ensure t
  :hook (org-mode . evil-org-mode))
#+END_SRC

** IEEE export
For class assignments and who-knows-what in the future, I was able to integrate
a IEEE Conference template in org-mode export via Latex. To use it, just
include the IEEEtran class in your org file. It has not been thoroughly tested,
but its headers, index, abstract and general aesthetic works perfectly out of
the box.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
             t)
#+END_SRC

** Beamer export
We need to manually enable the export to Beamer option

#+BEGIN_SRC emacs-lisp
(use-package ox-beamer)
#+END_SRC
** Native =TAB= in source blocks
By default =TAB= keystroke doesn't indent in =org= source blocks. Typing
=C-q-<TAB>= I can force a native =TAB= but I prefer this option that makes
=TAB= work as if the keystroke was issued in the codeâ€™s major mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

** Use syntax highlight in source blocks
When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

** Source syntax highlight in =latex= exports
Using =org-mode= =latex= export you can get syntax highlighting in pdf using
the =minted= package, wich uses =Python= =pygments= package. This snippet was
taken from [[http://joonro.github.io/blog/posts/org-mode-outputdir-minted-latex-export.html][Joon's Blog]]. [[https://github.com/gpoore/minted/issues/92][Issue]] ~cache=false~.

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("cache=false" "minted"))
(setq org-latex-listings 'minted)
#+END_SRC

** Auto cleanup =latex= intermediary files
I hate all this intermediary files that =latex= creates. Just blow up all my
directories. So, I've found a solution in this [[https://emacs.stackexchange.com/questions/23982/cleanup-org-mode-export-intermediary-file][emacs stack exchange question]].

#+BEGIN_SRC emacs-lisp
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl")))
#+END_SRC

** Time tracking: Clocking
I've recently discovered this feature and is awesome. It enables time tracking
for tasks inside an agenda file.

~C-c C-x C-i~ Starts the clock on the current time
~C-c C-x C-o~ Stops the current active clock

With this option all the =CLOCKS= will be grouped into a =:CLOCKING:= entry

#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
#+END_SRC

* Packages & Tools
** Move buffers around
There's no fast way to swap buffers location in Emacs by default. To do it, a
good option is to use =buffer-move= package and use these key bindings.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-x w <up>"    . buf-move-up)
		 ("C-x w <down>"  . buf-move-down)
		 ("C-x w <left>"  . buf-move-left)
		 ("C-x w <right>" . buf-move-right)
		 ("C-x w k"       . buf-move-up)
		 ("C-x w j"       . buf-move-down)
		 ("C-x w h"       . buf-move-left)
		 ("C-x w l"       . buf-move-right)))
#+END_SRC

** =ivy=
=ivy= is a minimalistic completion engine. It supports fuzzy matching. But I
don't like this behaviour on =swiper= search engine. So, I deactivated setting
the default regexp builder with ~(swiper . ivy--regex-plus)~.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :demand t
  :config

  (ivy-mode) 
  (setq ivy-use-virtual-buffers t
		ivy-count-format "%d/%d ")

  (setq ivy-wrap t)

  ; Fuzzy mode
  (setq ivy-re-builders-alist
		'((swiper . ivy--regex-plus) ; No Fuzzy matchin for swiper
		  (t      . ivy--regex-fuzzy)))

  (setq ivy-initial-inputs-alist nil)

  :bind (("C-s" . swiper)
		 :map ivy-minibuffer-map
		 ("RET" . ivy-alt-done)
		 ("C-j" . ivy-next-line)
		 ("C-k" . ivy-previous-line))) 
#+END_SRC

Also, this alternative package complement =ivy=

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :ensure t
  :demand t
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer
							   'ivy-rich-switch-buffer-transformer))
#+END_SRC

=counsel= is collection of Ivy-enhanced versions of common Emacs commands. So,
enhances the emacs user experience ;)

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :demand t) 
#+END_SRC

=swiper= is an Ivy-enhanced alternative to isearch

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :demand t)
#+END_SRC

** =projectile=
Enables different tools and functions to deal with files related to a
project. It works out of the box, since it will detect your *VCS* files
automatically and set it as the root of the project. If it doesn't, you can
just create an empty =.projectile= file in the root of your project.

I have it configured to ignore all files that has not been staged in the
project.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config

  (projectile-global-mode t)
  (setq projectile-use-git-grep t))
#+END_SRC

Also, the =counsel-projectile= extension adds integration with =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :config (counsel-projectile-mode t))
#+END_SRC
** =flycheck=
=Flycheck= brings on-the-fly syntax checking for different languages. It comes
already with support for a lot of languages and can also use other packages as
backend.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'flycheck-mode)
  (set-face-underline 'flycheck-error '(:color "Red1" :style line)))
#+END_SRC

** =smartparens=
Auto-close parenthesis and other characters. Very useful in =prog-mode=.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config

  (add-hook 'prog-mode-hook #'smartparens-mode)
  (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
#+END_SRC
** PDF Tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config

  (pdf-tools-install))

#+END_SRC
  
There's a conflict between =evil-mode= and =pdf-view-mode=. =evil= cause that
pdf display keeps blinking. [[https://github.com/politza/pdf-tools/issues/201][xuhdev]] gives a solution to deal with this conflict.

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'pdf-view-mode 'emacs)
(add-hook 'pdf-view-mode-hook
  (lambda ()
    (set (make-local-variable 'evil-emacs-state-cursor) (list nil))))
#+END_SRC
* Acknowledgments
- Thanks to Diego Vicente. He discovered me Emacs and =org-mode=. Also, many
  aspects of my Emacs file are inpired by his [[https://github.com/DiegoVicen/my-emacs][config file]].

* TODO-List
** TODO Format and document all the config file
** TODO Add different hooks for different mayor modes like org-mode
** TODO Configure Emacs as an IDE
*** TODO Python
*** TODO C++
*** TODO C#
